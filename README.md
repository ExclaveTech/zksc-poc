# ZK State Channels
## Why do we need ZK State Channels？
The cost of usage and transaction throughput on the Ethereum mainnet has always been a constraint on the development of on-chain applications. The emergence of Fully On-chain Gaming (FOCG) further highlights the urgency of current scalability. Traditional solutions like Validium or State Channels are only capable of building applications based on simple off-chain transaction logic and cannot support complex game logic. Therefore, designing a scalable solution that balances cost and compatibility becomes especially important.
ZK State Channel is a novel scaling solution based on state channels, Validium data availability, and recursive zero-knowledge proofs. Its primary goal is to significantly reduce the on-chain transaction burden and user operational costs by utilizing state channels in conjunction with the Validium approach. Additionally, it leverages recursive zero-knowledge proofs and other techniques to construct sophisticated off-chain operating environments, making it an ideal infrastructure for high-transaction-volume and complex-operation-logic applications like Fully On-chain Gaming (FOCG), offering security, efficiency, and cost-effectiveness.
## How does it work？
ZK State Channel combines technologies such as Recursive zk-SNARKs and state channels to achieve an efficient, private, and scalable way of interacting with blockchain. The following are the core functional modules of ZK State Channel:
### 1. Off-Chain Execution Module
The off-chain executable modules include two main functionalities:
- zkEVM, an EVM-equivalent smart contract execution environment.
- A third-party data availability module designed based on Validium.
#### Low On-chain Costs
Validium was originally a Layer 2 scaling solution that, similar to zk-rollups, ensures the integrity and legality of off-chain transactions while not storing all transaction data on the Ethereum mainnet. Despite some compromise in data availability, it has brought significant scalability improvements to Ethereum. With the rapid development of data availability layer infrastructure (such as EigenDA, Celestia, Avail, etc.), the original Validium approach of using DAC to ensure data availability can be achieved with more secure and neutral third-party DA layers.
#### Friendly Contract Execution Environment
To facilitate developers in implementing their complex off-chain execution logic in ZK State Channel, an EVM-equivalent smart contract execution environment is essential. This environment will be integrated into every minimal unit, zk-Node, in the off-chain network. Developers can easily compile and deploy Solidity code in zkEVM, allowing dApps to include, but not limited to, FOCG based on game engines like MUD and on-chain trading exchanges.
### 2. On-Chain Contract Module
State Channels are a scalability technology with the core concept of executing transactions offline, only submitting the state (account balances, contract states, etc.) to the blockchain when necessary. In ZK State Channels, the on-chain contract module serves as the entry point for users to interact on-chain and manage on-chain states. It is used to lock the state when opening a state channel and settle it after the channel is closed.
#### Efficient & Streamlined dApp Framework
In an ideal design, we aim to build a low-integration-cost state channel construction framework that imposes no restrictions on the state progression within the channel and the termination logic of the channel, making it easy to support various types of applications. Leveraging recursive zero-knowledge proofs generated by the off-chain virtual execution environment, a highly adaptable dApp workflow is defined:
- Participants in the channel lock the state that needs to be initialized and open the state channel after completing on-chain signatures.
- Participants can freely execute operations in the off-chain virtual environment, with no strict reliance on round-robin signature rules, thanks to the presence of a sequencer.
- In case of on-chain state disputes, users need to take on-chain actions and rely on data availability modules to confirm the final state.
#### Universal Integration Interfaces
Any on-chain contract and off-chain logic can be integrated into a zk-state-channels dApp by exposing a few common function interfaces for the channel to use as conditions for state updates: isFinalized returns whether the application state outcome is final, and getOutcome returns the boolean or numerical result of the application.
```Solidity
// required interface for zk-state-channels dApp with boolean outcome
interface IBooleanOutcome {
    function isFinalized(bytes calldata _query) external view returns (bool);
    function getOutcome(bytes calldata _query) external view returns (bool);
}

// required interface for zk-state-channels dApp with numeric outcome
interface INumericOutcome {
    function isFinalized(bytes calldata _query) external view returns (bool);
    function getOutcome(bytes calldata _query) external view returns (uint);
}
```
Additionally, our framework provides a simplified template in Solidity to implement common on-chain logic for application disputes. By combining the contract template with off-chain data availability modules, developers can focus solely on application-specific logic without being burdened by any state channel-related complexities, such as signature verification, Transaction ID tracking, or state machine management.
Application contract developers only need to implement the following interfaces abstracted by the contract template (not the final product, for reference only):
```Solidity
/** 
 * @notice Get the app outcome 
 * @param _query Query args 
 * @return True if query satisfied 
 */
function getOutcome(bytes memory _query) public view returns (bool);

/** 
 * @notice Update app state according to an off-chain state proof 
 * @param _state Signed off-chain app state 
 * @return True if update succeeds 
 */
function updateByState(bytes memory _state) internal returns (bool);

/** 
 * @notice Update app state according to an on-chain action 
 * @param _action Action data 
 * @return True if update succeeds 
 */
function updateByAction(bytes memory _action) internal returns (bool);

/** 
 * @notice Finalize the app outcome in case of on-chain action timeout 
 */
function finalizeOnTimeout() internal;

/** 
 * @notice Get app state associated with the given key 
 */
function getState(uint _key) external view returns (bytes memory);
```
### 3. Recursive zk-SNARKs Generation Module
In most applications, there is often a trade-off between time and space. Due to the increasing demand for throughput and performance in scenarios like FOCG, conventional batch generation of zero-knowledge proofs is insufficient to maximize off-chain scalability. Based on this, ZK State Channels introduce a new zk-proofs generation approach: recursive zero-knowledge proofs.
![High-level Structure of zk-state-channel]([https://example.com/my-image.png](https://github.com/zk-state-channel/zksc-poc/blob/main/zksc_pic_1.png))
#### Recursion + zk-SNARKs
Recursive Zero-Knowledge Proofs are a variant of zero-knowledge proofs that allow one proof to verify the correctness of another proof. In recursive zero-knowledge proofs, a proof can include a reference to another proof, enabling multiple proofs to be nested together, forming a proof chain for verification within the proof hierarchy.
Users of ZK State Channels perform off-chain operations through contract execution in a virtual environment. These operations batch together transaction data and generate zero-knowledge proofs. Leveraging the concise proofs of zkSNARKs, the generated zk-proofs are recursively generated to minimize on-chain data and verification costs.
Thanks to upgrades and improvements in the Plonky2 algorithm, recursive proofs based on the polynomial commitment scheme FRI can eliminate the trade-off between "proof size" and "proof time." In scenarios where proof time is a priority, optimizations can be applied to achieve maximum proof speed. Importantly, when these proofs are recursively aggregated, a single proof that can be verified in a smaller circuit is obtained. This means that proof size can be reduced to approximately 45kb, with a proof time of just 20 seconds.
